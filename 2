using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Security.Cryptography.X509Certificates;
using System.Text;

class Program
{
    // ---- PIV sabitleri ----
    static readonly byte[] PivAid   = { 0xA0,0x00,0x00,0x03,0x08,0x00,0x00,0x10,0x00,0x01,0x00 };
    const byte Slot9C               = 0x9C;              // Digital Signature
    static readonly byte[] OidCert9C= { 0x5F, 0xC1, 0x0B }; // GET DATA selector

    static void Main()
    {
        try
        {
            Console.Write("PIV PIN (örn. 123456): ");
            string pin = ReadHidden();

            string message = "imzalanacak metin";

            using (var sc = SmartCard.ConnectFirstPresent())
            {
                Console.WriteLine("[*] Reader: " + sc.ReaderName);

                // 1) SELECT PIV
                ApduOk(sc.Transmit(new Apdu(0x00, 0xA4, 0x04, 0x00, PivAid)));

                // 2) 9C sertifika
                byte[] certDer = GetCert9C(sc);
                var cert = new X509Certificate2(certDer);
                Console.WriteLine("[*] 9C Subject: " + cert.Subject);
                Console.WriteLine("[*] 9C PublicKey OID: " + cert.PublicKey.Oid.Value);

                Console.WriteLine("\n----- 9C CERT PEM -----\n" + ToPem("CERTIFICATE", certDer));

                bool isRsa = cert.PublicKey.Oid.Value == "1.2.840.113549.1.1.1"; // rsaEncryption

                // 3) PIN VERIFY (global PIN, P2=0x80)
                ApduOk(sc.Transmit(new Apdu(0x00, 0x20, 0x00, 0x80, Encoding.ASCII.GetBytes(pin))));

                // 4) GENERAL AUTHENTICATE ile imza
                byte[] dataToSign;
                if (isRsa)
                {
                    byte[] hash = SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes(message));
                    dataToSign = BuildDigestInfoSha256(hash); // RSA PKCS#1 v1.5 DigestInfo
                }
                else
                {
                    // EC için GA ham hash ister (P-256 varsaydık)
                    dataToSign = SHA256.Create().ComputeHash(Encoding.UTF8.GetBytes(message));
                }

                byte[] ga = Tlv(0x7C, Tlv(0x82, dataToSign));
                var resp = sc.Transmit(new Apdu(0x00, 0x87, 0x00, Slot9C, ga));
                ApduOk(resp);

                byte[] sig = ExtractNestedTlv(resp.Data, 0x7C, 0x82);
                if (sig == null) throw new Exception("İmza TLV bulunamadı.");
                string sigB64 = Convert.ToBase64String(sig);
                Console.WriteLine("\n[*] Signature (Base64):\n" + sigB64);

                // 5) Lokal doğrulama (RSA)
                if (isRsa)
                {
                    bool ok = VerifyLocalRsa(cert, message, sig);
                    Console.WriteLine("[VERIFY-LOCAL] " + (ok ? "OK" : "FAIL"));
                }
                else
                {
                    Console.WriteLine("[NOT] EC key: .NET 4.6 lokal ECDSA doğrulama örneği bu dosyada yok.");
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("HATA: " + ex);
        }
    }

    // ---- 9C sertifika GET DATA ----
    static byte[] GetCert9C(SmartCard sc)
    {
        // SELECT PIV (idempotent)
        ApduOk(sc.Transmit(new Apdu(0x00, 0xA4, 0x04, 0x00, PivAid)));

        // GET DATA: 00 CB 3F FF [ 5C 03 5F C1 0B ]
        byte[] selector = Tlv(0x5C, OidCert9C);
        var resp = sc.Transmit(new Apdu(0x00, 0xCB, 0x3F, 0xFF, selector));
        ApduOk(resp);

        byte[] der = TryExtractCertDer(resp.Data);
        if (der == null) throw new Exception("9C sertifikası bulunamadı.");
        return der;
    }

    // ---- RSA doğrulama (local) ----
    static bool VerifyLocalRsa(X509Certificate2 cert, string message, byte[] sig)
    {
        // .NET 4.6’da farklı RSA sağlayıcıları olabilir — sırayla dene
        var data = Encoding.UTF8.GetBytes(message);

        var rsaCsp = cert.PublicKey.Key as RSACryptoServiceProvider;
        if (rsaCsp != null)
        {
            var sha256 = new SHA256CryptoServiceProvider();
            return rsaCsp.VerifyData(data, sha256, sig);
        }

        var rsaCng = cert.PublicKey.Key as RSACng;
        if (rsaCng != null)
        {
            return rsaCng.VerifyData(data, sig, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
        }

        var rsa = cert.PublicKey.Key as RSA;
        if (rsa != null)
        {
            try { return rsa.VerifyData(data, sig, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1); }
            catch { }
        }

        return false;
    }

    // ---- TLV / ASN.1 yardımcıları ----
    static byte[] Tlv(int tag, byte[] value)
    {
        using (var ms = new MemoryStream())
        {
            ms.WriteByte((byte)tag);
            WriteLen(ms, value.Length);
            ms.Write(value, 0, value.Length);
            return ms.ToArray();
        }
    }
    static void WriteLen(Stream s, int len)
    {
        if (len < 0x80) s.WriteByte((byte)len);
        else if (len <= 0xFF) { s.WriteByte(0x81); s.WriteByte((byte)len); }
        else { s.WriteByte(0x82); s.WriteByte((byte)(len >> 8)); s.WriteByte((byte)(len & 0xFF)); }
    }
    struct TLV { public int tag; public byte[] val; public TLV(int t, byte[] v){ tag=t; val=v; } }
    static TLV? ReadTlv(byte[] buf, ref int pos)
    {
        if (pos >= buf.Length) return null;
        int tag = buf[pos++] & 0xFF;
        if (pos >= buf.Length) return null;
        int len = buf[pos++] & 0xFF;
        if (len == 0x81) { if (pos >= buf.Length) return null; len = buf[pos++] & 0xFF; }
        else if (len == 0x82) { if (pos + 1 >= buf.Length) return null; len = (buf[pos++] << 8) | buf[pos++]; }
        else if (len >= 0x80) throw new Exception("Desteklenmeyen length formu");
        if (pos + len > buf.Length) return null;
        var val = new byte[len];
        Buffer.BlockCopy(buf, pos, val, 0, len);
        pos += len;
        return new TLV(tag, val);
    }
    static byte[] ExtractNestedTlv(byte[] data, int outerTag, int innerTag)
    {
        int p = 0;
        var outer = ReadTlv(data, ref p);
        if (outer == null || outer.Value.tag != outerTag) return null;
        int q = 0; var span = outer.Value.val;
        while (q < span.Length)
        {
            var inner = ReadTlv(span, ref q);
            if (inner == null) break;
            if (inner.Value.tag == innerTag) return inner.Value.val;
        }
        return null;
    }
    static byte[] TryExtractCertDer(byte[] resp)
    {
        int p = 0;
        var t = ReadTlv(resp, ref p);
        if (t == null) return null;
        if (t.Value.tag == 0x70) return t.Value.val;                 // doğrudan DER
        int q = 0; var t2 = ReadTlv(t.Value.val, ref q);
        if (t2 != null && t2.Value.tag == 0x70) return t2.Value.val; // 53[70[DER]]
        return null;
    }

    // ASN.1 DigestInfo for SHA-256 (RSA PKCS#1 v1.5)
    static byte[] BuildDigestInfoSha256(byte[] sha256)
    {
        byte[] prefix = {
            0x30,0x31, 0x30,0x0D,
            0x06,0x09,0x60,0x86,0x48,0x01,0x65,0x03,0x04,0x02,0x01,
            0x05,0x00, 0x04,0x20
        };
        var result = new byte[prefix.Length + sha256.Length];
        Buffer.BlockCopy(prefix, 0, result, 0, prefix.Length);
        Buffer.BlockCopy(sha256, 0, result, prefix.Length, sha256.Length);
        return result;
    }

    static string ToPem(string kind, byte[] der)
    {
        string b64 = Convert.ToBase64String(der, Base64FormattingOptions.InsertLineBreaks);
        return "-----BEGIN " + kind + "-----\n" + b64 + "\n-----END " + kind + "-----\n";
    }

    static void ApduOk(ApduResponse r)
    {
        if (r.SW != 0x9000) throw new Exception("APDU hata: " + r.SW.ToString("X4"));
    }

    static string ReadHidden()
    {
        var sb = new StringBuilder();
        for (;;)
        {
            var k = Console.ReadKey(true);
            if (k.Key == ConsoleKey.Enter) { Console.WriteLine(); break; }
            if (k.Key == ConsoleKey.Backspace && sb.Length > 0) { sb.Remove(sb.Length-1,1); continue; }
            if (!char.IsControl(k.KeyChar)) sb.Append(k.KeyChar);
        }
        return sb.ToString();
    }
}

// =================== winscard.dll köprü + APDU tipleri (char[] FIX'li) ===================
sealed class SmartCard : IDisposable
{
    IntPtr _ctx;
    IntPtr _card;
    string _reader = "";
    public string ReaderName { get { return _reader; } }

    SmartCard() {}

    public static SmartCard ConnectFirstPresent()
    {
        var sc = new SmartCard();

        int rc = WinSCard.SCardEstablishContext(WinSCard.SCARD_SCOPE_USER, IntPtr.Zero, IntPtr.Zero, out sc._ctx);
        Check(rc, "SCardEstablishContext");

        // --- Reader listesini al (UNICODE char[] ile) ---
        uint charCount = 0;
        rc = WinSCard.SCardListReaders(sc._ctx, null, null, ref charCount);
        Check(rc, "SCardListReaders(size)");
        if (charCount == 0) throw new Exception("Reader bulunamadı.");

        var chars = new char[charCount]; // KARAKTER sayısı kadar ayır
        rc = WinSCard.SCardListReaders(sc._ctx, null, chars, ref charCount);
        Check(rc, "SCardListReaders");

        string all = new string(chars).TrimEnd('\0');
        var readers = all.Split(new[] { '\0' }, StringSplitOptions.RemoveEmptyEntries);
        if (readers.Length == 0) throw new Exception("Reader bulunamadı.");

        // --- İlk takılı karta bağlan ---
        foreach (var r in readers)
        {
            IntPtr card; uint proto;
            rc = WinSCard.SCardConnect(sc._ctx, r,
                WinSCard.SCARD_SHARE_SHARED,
                WinSCard.SCARD_PROTOCOL_T0 | WinSCard.SCARD_PROTOCOL_T1,
                out card, out proto);
            if (rc == WinSCard.SCARD_S_SUCCESS)
            {
                sc._card = card;
                sc._reader = r;
                return sc;
            }
        }
        throw new Exception("Kart takılı reader bulunamadı.");
    }

    public ApduResponse Transmit(Apdu apdu)
    {
        byte[] send = apdu.ToArray();
        byte[] recv = new byte[4096];

        var ioSend = new WinSCard.SCARD_IO_REQUEST();
        ioSend.dwProtocol = WinSCard.SCARD_PROTOCOL_T1;
        ioSend.cbPciLength = (uint)Marshal.SizeOf(typeof(WinSCard.SCARD_IO_REQUEST));

        var ioRecv = new WinSCard.SCARD_IO_REQUEST();
        ioRecv.dwProtocol = WinSCard.SCARD_PROTOCOL_T1;
        ioRecv.cbPciLength = (uint)Marshal.SizeOf(typeof(WinSCard.SCARD_IO_REQUEST));

        uint recvLen;
        int rc = WinSCard.SCardTransmit(_card, ref ioSend, send, send.Length, ref ioRecv, recv, out recvLen);
        Check(rc, "SCardTransmit");

        if (recvLen < 2) throw new Exception("APDU cevabı kısa.");
        ushort sw = (ushort)((recv[recvLen - 2] << 8) | recv[recvLen - 1]);
        var data = new byte[recvLen - 2];
        Buffer.BlockCopy(recv, 0, data, 0, data.Length);
        return new ApduResponse(data, sw);
    }

    public void Dispose()
    {
        if (_card != IntPtr.Zero) { WinSCard.SCardDisconnect(_card, WinSCard.SCARD_LEAVE_CARD); _card = IntPtr.Zero; }
        if (_ctx  != IntPtr.Zero) { WinSCard.SCardReleaseContext(_ctx); _ctx = IntPtr.Zero; }
    }

    static void Check(int rc, string where)
    {
        if (rc != WinSCard.SCARD_S_SUCCESS)
            throw new System.ComponentModel.Win32Exception(rc, where + " failed: 0x" + rc.ToString("X"));
    }
}

struct Apdu
{
    public byte Cla, Ins, P1, P2;
    public byte[] Data;
    public Apdu(byte cla, byte ins, byte p1, byte p2, byte[] data = null)
    {
        Cla = cla; Ins = ins; P1 = p1; P2 = p2; Data = data;
    }
    public byte[] ToArray()
    {
        if (Data == null || Data.Length == 0)
            return new byte[] { Cla, Ins, P1, P2, 0x00 };
        byte[] apdu = new byte[5 + Data.Length];
        apdu[0] = Cla; apdu[1] = Ins; apdu[2] = P1; apdu[3] = P2; apdu[4] = (byte)Data.Length;
        Buffer.BlockCopy(Data, 0, apdu, 5, Data.Length);
        return apdu;
    }
}
struct ApduResponse
{
    public byte[] Data;
    public ushort SW;
    public ApduResponse(byte[] d, ushort sw) { Data = d; SW = sw; }
}

static class WinSCard
{
    public const int SCARD_S_SUCCESS = 0;
    public const uint SCARD_SCOPE_USER = 0;
    public const uint SCARD_SHARE_SHARED = 2;
    public const uint SCARD_PROTOCOL_T0 = 0x0001;
    public const uint SCARD_PROTOCOL_T1 = 0x0002;
    public const uint SCARD_LEAVE_CARD = 0;

    [StructLayout(LayoutKind.Sequential)]
    public struct SCARD_IO_REQUEST
    {
        public uint dwProtocol;
        public uint cbPciLength;
    }

    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardEstablishContext(uint dwScope, IntPtr notUsed1, IntPtr notUsed2, out IntPtr phContext);

    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardReleaseContext(IntPtr hContext);

    // *** DÜZELTİLMİŞ İMZA: char[] buffer ve pcchReaders = karakter sayısı ***
    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardListReaders(IntPtr hContext, string mszGroups, char[] mszReaders, ref uint pcchReaders);

    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardConnect(IntPtr hContext, string szReader, uint dwShareMode, uint dwPreferredProtocols,
                                          out IntPtr phCard, out uint pdwActiveProtocol);

    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardDisconnect(IntPtr hCard, uint dwDisposition);

    [DllImport("winscard.dll", CharSet = CharSet.Unicode)]
    public static extern int SCardTransmit(IntPtr hCard, ref SCARD_IO_REQUEST pioSendPci,
                                           byte[] pbSendBuffer, int cbSendLength,
                                           ref SCARD_IO_REQUEST pioRecvPci,
                                           byte[] pbRecvBuffer, out uint pcbRecvLength);
}
